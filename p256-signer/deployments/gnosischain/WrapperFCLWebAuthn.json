{
  "address": "0xd45686ea15cb5D830FFb3fA320E46ADD146ab9a4",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidAuthenticatorData",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidClientData",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "authenticatorData",
          "type": "bytes"
        },
        {
          "internalType": "bytes1",
          "name": "authenticatorDataFlagMask",
          "type": "bytes1"
        },
        {
          "internalType": "bytes",
          "name": "clientData",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "clientChallenge",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "clientChallengeDataOffset",
          "type": "uint256"
        },
        {
          "internalType": "uint256[2]",
          "name": "rs",
          "type": "uint256[2]"
        },
        {
          "internalType": "uint256[2]",
          "name": "Q",
          "type": "uint256[2]"
        }
      ],
      "name": "checkSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xbea41db4536165aad6568995c516224bdb15c4417874f0ef64dce51162991212",
  "receipt": {
    "to": "0x6A78a27E52fa669C0a5246574Ece2e9a64c483B1",
    "from": "0x00f8C039BBc88085f07f9aA1e92DEdc8BBE01CC8",
    "contractAddress": null,
    "transactionIndex": 1,
    "gasUsed": "1488537",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xad1779115408806721acdc17e8eebb23c915256503e23669e52f1558de8db3fe",
    "transactionHash": "0xbea41db4536165aad6568995c516224bdb15c4417874f0ef64dce51162991212",
    "logs": [],
    "blockNumber": 31001584,
    "cumulativeGasUsed": "1532111",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "9a239a13792e7e509c47a689d8b7e7c4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidAuthenticatorData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidClientData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"authenticatorData\",\"type\":\"bytes\"},{\"internalType\":\"bytes1\",\"name\":\"authenticatorDataFlagMask\",\"type\":\"bytes1\"},{\"internalType\":\"bytes\",\"name\":\"clientData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"clientChallenge\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"clientChallengeDataOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"rs\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"Q\",\"type\":\"uint256[2]\"}],\"name\":\"checkSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This lib is only a wrapper around the FCL_WebAuthn library.      It is meant to be used with 1271 signatures.      The wrapping is necessary because the FCL_WebAuthn has only internal      functions and use calldata. This makes it impossible to use it with      isValidSignature that use memory.\",\"kind\":\"dev\",\"methods\":{},\"title\":\"WrapperFCLWebAuthn\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library used to verify ECDSA signatures over secp256r1 through         EIP-1271 of Webauthn payloads.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/FCL/WrapperFCLWebAuthn.sol\":\"WrapperFCLWebAuthn\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"FreshCryptoLib/FCL_Webauthn.sol\":{\"content\":\"//********************************************************************************************/\\n//  ___           _       ___               _         _    _ _\\n// | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__\\n// | _| '_/ -_|_-< ' \\\\  | (__| '_| || | '_ \\\\  _/ _ \\\\ | |__| | '_ \\\\\\n// |_||_| \\\\___/__/_||_|  \\\\___|_|  \\\\_, | .__/\\\\__\\\\___/ |____|_|_.__/\\n///* Copyright (C) 2022 - Renaud Dubois - This file is part of FCL (Fresh CryptoLib) project\\n///* License: This software is licensed under MIT License\\n///* This Code may be reused including license and copyright notice.\\n///* See LICENSE file at the root folder of the project.\\n///* FILE: FCL_elliptic.sol\\n///*\\n///*\\n///* DESCRIPTION: Implementation of the WebAuthn Authentication mechanism\\n///* https://www.w3.org/TR/webauthn-2/#sctn-intro\\n///* Original code extracted from https://github.com/btchip/Webauthn.sol\\n//**************************************************************************************/\\n//* WARNING: this code SHALL not be used for non prime order curves for security reasons.\\n// Code is optimized for a=-3 only curves with prime order, constant like -1, -2 shall be replaced\\n// if ever used for other curve than sec256R1\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Base64Url} from \\\"./utils/Base64Url.sol\\\";\\nimport {FCL_Elliptic_ZZ} from \\\"./FCL_elliptic.sol\\\";\\n\\nlibrary FCL_WebAuthn {\\n    error InvalidAuthenticatorData();\\n    error InvalidClientData();\\n    error InvalidSignature();\\n\\n    function WebAuthn_format(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata // rs\\n    ) internal pure returns (bytes32 result) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n        {\\n            if ((authenticatorData[32] & authenticatorDataFlagMask) != authenticatorDataFlagMask) {\\n                revert InvalidAuthenticatorData();\\n            }\\n            // Verify that clientData commits to the expected client challenge\\n            // Use the Base64Url encoding which omits padding characters to match WebAuthn Specification\\n            string memory challengeEncoded = Base64Url.encode(abi.encodePacked(clientChallenge));\\n            bytes memory challengeExtracted = new bytes(\\n            bytes(challengeEncoded).length\\n        );\\n\\n            assembly {\\n                calldatacopy(\\n                    add(challengeExtracted, 32),\\n                    add(clientData.offset, clientChallengeDataOffset),\\n                    mload(challengeExtracted)\\n                )\\n            }\\n\\n            bytes32 moreData; //=keccak256(abi.encodePacked(challengeExtracted));\\n            assembly {\\n                moreData := keccak256(add(challengeExtracted, 32), mload(challengeExtracted))\\n            }\\n\\n            if (keccak256(abi.encodePacked(bytes(challengeEncoded))) != moreData) {\\n                revert InvalidClientData();\\n            }\\n        } //avoid stack full\\n\\n        // Verify the signature over sha256(authenticatorData || sha256(clientData))\\n        bytes memory verifyData = new bytes(authenticatorData.length + 32);\\n\\n        assembly {\\n            calldatacopy(add(verifyData, 32), authenticatorData.offset, authenticatorData.length)\\n        }\\n\\n        bytes32 more = sha256(clientData);\\n        assembly {\\n            mstore(add(verifyData, add(authenticatorData.length, 32)), more)\\n        }\\n\\n        return sha256(verifyData);\\n    }\\n\\n    function  checkSignature (\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        uint256[2] calldata Q\\n    ) internal view returns (bool) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n\\n        bytes32 message = FCL_WebAuthn.WebAuthn_format(\\n            authenticatorData, authenticatorDataFlagMask, clientData, clientChallenge, clientChallengeDataOffset, rs\\n        );\\n\\n        bool result = FCL_Elliptic_ZZ.ecdsa_verify(message, rs, Q);\\n\\n        return result;\\n    }\\n\\n    function checkSignature_prec(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        address dataPointer\\n    ) internal view returns (bool) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n\\n        bytes32 message = FCL_WebAuthn.WebAuthn_format(\\n            authenticatorData, authenticatorDataFlagMask, clientData, clientChallenge, clientChallengeDataOffset, rs\\n        );\\n\\n        bool result = FCL_Elliptic_ZZ.ecdsa_precomputed_verify(message, rs, dataPointer);\\n\\n        return result;\\n    }\\n\\n    //beware that this implementation will not be compliant with EOF\\n    function checkSignature_hackmem(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        uint256 dataPointer\\n    ) internal view returns (bool) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n\\n        bytes32 message = FCL_WebAuthn.WebAuthn_format(\\n            authenticatorData, authenticatorDataFlagMask, clientData, clientChallenge, clientChallengeDataOffset, rs\\n        );\\n\\n        bool result = FCL_Elliptic_ZZ.ecdsa_precomputed_hackmem(message, rs, dataPointer);\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x78658514b1f160f17b8408bddc3615b2bfaf83a50c874cdfba26ce90528214b4\",\"license\":\"MIT\"},\"FreshCryptoLib/FCL_elliptic.sol\":{\"content\":\"//********************************************************************************************/\\n//  ___           _       ___               _         _    _ _\\n// | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__\\n// | _| '_/ -_|_-< ' \\\\  | (__| '_| || | '_ \\\\  _/ _ \\\\ | |__| | '_ \\\\\\n// |_||_| \\\\___/__/_||_|  \\\\___|_|  \\\\_, | .__/\\\\__\\\\___/ |____|_|_.__/\\n//                                |__/|_|\\n///* Copyright (C) 2022 - Renaud Dubois - This file is part of FCL (Fresh CryptoLib) project\\n///* License: This software is licensed under MIT License\\n///* This Code may be reused including license and copyright notice.\\n///* See LICENSE file at the root folder of the project.\\n///* FILE: FCL_elliptic.sol\\n///*\\n///*\\n///* DESCRIPTION: modified XYZZ system coordinates for EVM elliptic point multiplication\\n///*  optimization\\n///*\\n//**************************************************************************************/\\n//* WARNING: this code SHALL not be used for non prime order curves for security reasons.\\n// Code is optimized for a=-3 only curves with prime order, constant like -1, -2 shall be replaced\\n// if ever used for other curve than sec256R1\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary FCL_Elliptic_ZZ {\\n    // Set parameters for curve sec256r1.\\n\\n    // address of the ModExp precompiled contract (Arbitrary-precision exponentiation under modulo)\\n    address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005;\\n    //curve prime field modulus\\n    uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n    //short weierstrass first coefficient\\n    uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\\n    //short weierstrass second coefficient\\n    uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\\n    //generating point affine coordinates\\n    uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\\n    uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\\n    //curve order (number of points)\\n    uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\\n    /* -2 mod p constant, used to speed up inversion and doubling (avoid negation)*/\\n    uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD;\\n    /* -2 mod n constant, used to speed up inversion*/\\n    uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F;\\n\\n    uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    //P+1 div 4\\n    uint256 constant pp1div4=0x3fffffffc0000000400000000000000000000000400000000000000000000000;\\n    //arbitrary constant to express no quadratic residuosity\\n    uint256 constant _NOTSQUARE=0xFFFFFFFF00000002000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 constant _NOTONCURVE=0xFFFFFFFF00000003000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    /**\\n     * /* inversion mod n via a^(n-2), use of precompiled using little Fermat theorem\\n     */\\n    function FCL_nModInv(uint256 u) internal view returns (uint256 result) {\\n        assembly {\\n            let pointer := mload(0x40)\\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n            mstore(pointer, 0x20)\\n            mstore(add(pointer, 0x20), 0x20)\\n            mstore(add(pointer, 0x40), 0x20)\\n            // Define variables base, exponent and modulus\\n            mstore(add(pointer, 0x60), u)\\n            mstore(add(pointer, 0x80), minus_2modn)\\n            mstore(add(pointer, 0xa0), n)\\n\\n            // Call the precompiled contract 0x05 = ModExp\\n            if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\\n            result := mload(pointer)\\n        }\\n    }\\n    /**\\n     * /* @dev inversion mod nusing little Fermat theorem via a^(n-2), use of precompiled\\n     */\\n\\n    function FCL_pModInv(uint256 u) internal view returns (uint256 result) {\\n        assembly {\\n            let pointer := mload(0x40)\\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n            mstore(pointer, 0x20)\\n            mstore(add(pointer, 0x20), 0x20)\\n            mstore(add(pointer, 0x40), 0x20)\\n            // Define variables base, exponent and modulus\\n            mstore(add(pointer, 0x60), u)\\n            mstore(add(pointer, 0x80), minus_2)\\n            mstore(add(pointer, 0xa0), p)\\n\\n            // Call the precompiled contract 0x05 = ModExp\\n            if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\\n            result := mload(pointer)\\n        }\\n    }\\n\\n    //Coron projective shuffling, take as input alpha as blinding factor\\n   function ecZZ_Coronize(uint256 alpha, uint256 x, uint256 y,  uint256 zz, uint256 zzz) public pure  returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\\n   {\\n       \\n        uint256 alpha2=mulmod(alpha,alpha,p);\\n       \\n        x3=mulmod(alpha2, x,p); //alpha^-2.x\\n        y3=mulmod(mulmod(alpha, alpha2,p), y,p);\\n\\n        zz3=mulmod(zz,alpha2,p);//alpha^2 zz\\n        zzz3=mulmod(zzz,mulmod(alpha, alpha2,p),p);//alpha^3 zzz\\n        \\n        return (x3, y3, zz3, zzz3);\\n   }\\n\\n\\n function ecZZ_Add(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2, uint256 zz2, uint256 zzz2) internal pure  returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\\n  {\\n    uint256 u1=mulmod(x1,zz2,p); // U1 = X1*ZZ2\\n    uint256 u2=mulmod(x2, zz1,p);               //  U2 = X2*ZZ1\\n    u2=addmod(u2, p-u1, p);//  P = U2-U1\\n    x1=mulmod(u2, u2, p);//PP\\n    x2=mulmod(x1, u2, p);//PPP\\n    \\n    zz3=mulmod(x1, mulmod(zz1, zz2, p),p);//ZZ3 = ZZ1*ZZ2*PP  \\n    zzz3=mulmod(zzz1, mulmod(zzz2, x2, p),p);//ZZZ3 = ZZZ1*ZZZ2*PPP\\n\\n    zz1=mulmod(y1, zzz2,p);  // S1 = Y1*ZZZ2\\n    zz2=mulmod(y2, zzz1, p);    // S2 = Y2*ZZZ1 \\n    zz2=addmod(zz2, p-zz1, p);//R = S2-S1\\n    zzz1=mulmod(u1, x1,p); //Q = U1*PP\\n    x3= addmod(addmod(mulmod(zz2, zz2, p), p-x2,p), mulmod(minus_2, zzz1,p),p); //X3 = R2-PPP-2*Q\\n    y3=addmod( mulmod(zz2, addmod(zzz1, p-x3, p),p), p-mulmod(zz1, x2, p),p);//R*(Q-X3)-S1*PPP\\n\\n    return (x3, y3, zz3, zzz3);\\n  }\\n\\n/// @notice Calculate one modular square root of a given integer. Assume that p=3 mod 4.\\n/// @dev Uses the ModExp precompiled contract at address 0x05 for fast computation using little Fermat theorem\\n/// @param self The integer of which to find the modular inverse\\n/// @return result The modular inverse of the input integer. If the modular inverse doesn't exist, it revert the tx\\n\\nfunction SqrtMod(uint256 self) internal view returns (uint256 result){\\n assembly (\\\"memory-safe\\\") {\\n        // load the free memory pointer value\\n        let pointer := mload(0x40)\\n\\n        // Define length of base (Bsize)\\n        mstore(pointer, 0x20)\\n        // Define the exponent size (Esize)\\n        mstore(add(pointer, 0x20), 0x20)\\n        // Define the modulus size (Msize)\\n        mstore(add(pointer, 0x40), 0x20)\\n        // Define variables base (B)\\n        mstore(add(pointer, 0x60), self)\\n        // Define the exponent (E)\\n        mstore(add(pointer, 0x80), pp1div4)\\n        // We save the point of the last argument, it will be override by the result\\n        // of the precompile call in order to avoid paying for the memory expansion properly\\n        let _result := add(pointer, 0xa0)\\n        // Define the modulus (M)\\n        mstore(_result, p)\\n\\n        // Call the precompiled ModExp (0x05) https://www.evm.codes/precompiled#0x05\\n        if iszero(\\n            staticcall(\\n                not(0), // amount of gas to send\\n                MODEXP_PRECOMPILE, // target\\n                pointer, // argsOffset\\n                0xc0, // argsSize (6 * 32 bytes)\\n                _result, // retOffset (we override M to avoid paying for the memory expansion)\\n                0x20 // retSize (32 bytes)\\n            )\\n        ) { revert(0, 0) }\\n\\n  result := mload(_result)\\n//  result :=addmod(result,0,p)\\n }\\n   if(mulmod(result,result,p)!=self){\\n     result=_NOTSQUARE;\\n   }\\n  \\n   return result;\\n}\\n    /**\\n     * /* @dev Convert from affine rep to XYZZ rep\\n     */\\n    function ecAff_SetZZ(uint256 x0, uint256 y0) internal pure returns (uint256[4] memory P) {\\n        unchecked {\\n            P[2] = 1; //ZZ\\n            P[3] = 1; //ZZZ\\n            P[0] = x0;\\n            P[1] = y0;\\n        }\\n    }\\n\\n    function ec_Decompress(uint256 x, uint256 parity) internal view returns(uint256 y){ \\n\\n        uint256 y2=mulmod(x,mulmod(x,x,p),p);//x3\\n        y2=addmod(b,addmod(y2,mulmod(x,a,p),p),p);//x3+ax+b\\n\\n        y=SqrtMod(y2);\\n        if(y==_NOTSQUARE){\\n           return _NOTONCURVE;\\n        }\\n        if((y&1)!=(parity&1)){\\n            y=p-y;\\n        }\\n    }\\n\\n    /**\\n     * /* @dev Convert from XYZZ rep to affine rep\\n     */\\n    /*    https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html#addition-add-2008-s*/\\n    function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) internal view returns (uint256 x1, uint256 y1) {\\n        uint256 zzzInv = FCL_pModInv(zzz); //1/zzz\\n        y1 = mulmod(y, zzzInv, p); //Y/zzz\\n        uint256 _b = mulmod(zz, zzzInv, p); //1/z\\n        zzzInv = mulmod(_b, _b, p); //1/zz\\n        x1 = mulmod(x, zzzInv, p); //X/zz\\n    }\\n\\n    /**\\n     * /* @dev Sutherland2008 doubling\\n     */\\n    /* The \\\"dbl-2008-s-1\\\" doubling formulas */\\n\\n    function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz)\\n        internal\\n        pure\\n        returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\\n    {\\n        unchecked {\\n            assembly {\\n                P0 := mulmod(2, y, p) //U = 2*Y1\\n                P2 := mulmod(P0, P0, p) // V=U^2\\n                P3 := mulmod(x, P2, p) // S = X1*V\\n                P1 := mulmod(P0, P2, p) // W=UV\\n                P2 := mulmod(P2, zz, p) //zz3=V*ZZ1\\n                zz := mulmod(3, mulmod(addmod(x, sub(p, zz), p), addmod(x, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                P0 := addmod(mulmod(zz, zz, p), mulmod(minus_2, P3, p), p) //X3=M^2-2S\\n                x := mulmod(zz, addmod(P3, sub(p, P0), p), p) //M(S-X3)\\n                P3 := mulmod(P1, zzz, p) //zzz3=W*zzz1\\n                P1 := addmod(x, sub(p, mulmod(P1, y, p)), p) //Y3= M(S-X3)-W*Y1\\n            }\\n        }\\n        return (P0, P1, P2, P3);\\n    }\\n\\n    /**\\n     * @dev Sutherland2008 add a ZZ point with a normalized point and greedy formulae\\n     * warning: assume that P1(x1,y1)!=P2(x2,y2), true in multiplication loop with prime order (cofactor 1)\\n     */\\n\\n    function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2)\\n        internal\\n        pure\\n        returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\\n    {\\n        unchecked {\\n            if (y1 == 0) {\\n                return (x2, y2, 1, 1);\\n            }\\n\\n            assembly {\\n                y1 := sub(p, y1)\\n                y2 := addmod(mulmod(y2, zzz1, p), y1, p)\\n                x2 := addmod(mulmod(x2, zz1, p), sub(p, x1), p)\\n                P0 := mulmod(x2, x2, p) //PP = P^2\\n                P1 := mulmod(P0, x2, p) //PPP = P*PP\\n                P2 := mulmod(zz1, P0, p) ////ZZ3 = ZZ1*PP\\n                P3 := mulmod(zzz1, P1, p) ////ZZZ3 = ZZZ1*PPP\\n                zz1 := mulmod(x1, P0, p) //Q = X1*PP\\n                P0 := addmod(addmod(mulmod(y2, y2, p), sub(p, P1), p), mulmod(minus_2, zz1, p), p) //R^2-PPP-2*Q\\n                P1 := addmod(mulmod(addmod(zz1, sub(p, P0), p), y2, p), mulmod(y1, P1, p), p) //R*(Q-X3)\\n            }\\n            //end assembly\\n        } //end unchecked\\n        return (P0, P1, P2, P3);\\n    }\\n\\n    /**\\n     * @dev Return the zero curve in XYZZ coordinates.\\n     */\\n    function ecZZ_SetZero() internal pure returns (uint256 x, uint256 y, uint256 zz, uint256 zzz) {\\n        return (0, 0, 0, 0);\\n    }\\n    /**\\n     * @dev Check if point is the neutral of the curve\\n     */\\n\\n    // uint256 x0, uint256 y0, uint256 zz0, uint256 zzz0\\n    function ecZZ_IsZero(uint256, uint256 y0, uint256, uint256) internal pure returns (bool) {\\n        return y0 == 0;\\n    }\\n    /**\\n     * @dev Return the zero curve in affine coordinates. Compatible with the double formulae (no special case)\\n     */\\n\\n    function ecAff_SetZero() internal pure returns (uint256 x, uint256 y) {\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * @dev Check if the curve is the zero curve in affine rep.\\n     */\\n    // uint256 x, uint256 y)\\n    function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) {\\n        return (y == 0);\\n    }\\n\\n    /**\\n     * @dev Check if a point in affine coordinates is on the curve (reject Neutral that is indeed on the curve).\\n     */\\n    function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\\n        if (0 == x || x == p || 0 == y || y == p) {\\n            return false;\\n        }\\n        unchecked {\\n            uint256 LHS = mulmod(y, y, p); // y^2\\n            uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(x, a, p), p); // x^3+ax\\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\\n\\n            return LHS == RHS;\\n        }\\n    }\\n\\n    /**\\n     * @dev Add two elliptic curve points in affine coordinates.\\n     */\\n\\n    function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) {\\n        uint256 zz0;\\n        uint256 zzz0;\\n\\n        if (ecAff_IsZero(x0, y0)) return (x1, y1);\\n        if (ecAff_IsZero(x1, y1)) return (x0, y0);\\n\\n        (x0, y0, zz0, zzz0) = ecZZ_AddN(x0, y0, 1, 1, x1, y1);\\n\\n        return ecZZ_SetAff(x0, y0, zz0, zzz0);\\n    }\\n\\n    /**\\n     * @dev Computation of uG+vQ using Strauss-Shamir's trick, G basepoint, Q public key\\n     *       Returns only x for ECDSA use            \\n     *      */\\n    function ecZZ_mulmuladd_S_asm(\\n        uint256 Q0,\\n        uint256 Q1, //affine rep for input point Q\\n        uint256 scalar_u,\\n        uint256 scalar_v\\n    ) internal view returns (uint256 X) {\\n        uint256 zz;\\n        uint256 zzz;\\n        uint256 Y;\\n        uint256 index = 255;\\n        uint256 H0;\\n        uint256 H1;\\n\\n        unchecked {\\n            if (scalar_u == 0 && scalar_v == 0) return 0;\\n\\n            (H0, H1) = ecAff_add(gx, gy, Q0, Q1); //will not work if Q=P, obvious forbidden private key\\n\\n            assembly {\\n                for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\\n                    index := sub(index, 1)\\n                    T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n                } {}\\n                zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                if eq(zz, 1) {\\n                    X := gx\\n                    Y := gy\\n                }\\n                if eq(zz, 2) {\\n                    X := Q0\\n                    Y := Q1\\n                }\\n                if eq(zz, 3) {\\n                    X := H0\\n                    Y := H1\\n                }\\n\\n                index := sub(index, 1)\\n                zz := 1\\n                zzz := 1\\n\\n                for {} gt(minus_1, index) { index := sub(index, 1) } {\\n                    // inlined EcZZ_Dbl\\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                    let T2 := mulmod(T1, T1, p) // V=U^2\\n                    let T3 := mulmod(X, T2, p) // S = X1*V\\n                    T1 := mulmod(T1, T2, p) // W=UV\\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                    {\\n                        //value of dibit\\n                        T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                        if iszero(T4) {\\n                            Y := sub(p, Y) //restore the -Y inversion\\n                            continue\\n                        } // if T4!=0\\n\\n                        if eq(T4, 1) {\\n                            T1 := gx\\n                            T2 := gy\\n                        }\\n                        if eq(T4, 2) {\\n                            T1 := Q0\\n                            T2 := Q1\\n                        }\\n                        if eq(T4, 3) {\\n                            T1 := H0\\n                            T2 := H1\\n                        }\\n                        if iszero(zz) {\\n                            X := T1\\n                            Y := T2\\n                            zz := 1\\n                            zzz := 1\\n                            continue\\n                        }\\n                        // inlined EcZZ_AddN\\n\\n                        //T3:=sub(p, Y)\\n                        //T3:=Y\\n                        let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\\n                        T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\\n\\n                        //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\\n                        //todo : construct edge vector case\\n                        if iszero(y2) {\\n                            if iszero(T2) {\\n                                T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\\n                                T2 := mulmod(T1, T1, p) // V=U^2\\n                                T3 := mulmod(X, T2, p) // S = X1*V\\n\\n                                T1 := mulmod(T1, T2, p) // W=UV\\n                                y2 := addmod(X, zz, p)  //X+ZZ\\n                                let TT1 := addmod(X, sub(p, zz), p) //X-ZZ\\n                                y2 := mulmod(y2, TT1, p) //(X-ZZ)(X+ZZ)\\n                                T4 := mulmod(3, y2, p) //M\\n\\n                                zzz := mulmod(TT1, zzz, p) //zzz3=W*zzz1\\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\\n\\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\\n\\n                                continue\\n                            }\\n                        }\\n\\n                        T4 := mulmod(T2, T2, p) //PP\\n                        let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\\n                        zz := mulmod(zz, T4, p)\\n                        zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\\n                        let TT2 := mulmod(X, T4, p)\\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\\n                        Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\\n\\n                        X := T4\\n                    }\\n                } //end loop\\n                let T := mload(0x40)\\n                mstore(add(T, 0x60), zz)\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                //Y:=mulmod(Y,zzz,p)//Y/zzz\\n                //zz :=mulmod(zz, mload(T),p) //1/z\\n                //zz:= mulmod(zz,zz,p) //1/zz\\n                X := mulmod(X, mload(T), p) //X/zz\\n            } //end assembly\\n        } //end unchecked\\n\\n        return X;\\n    }\\n\\n\\n    /**\\n     * @dev Computation of uG+vQ using Strauss-Shamir's trick, G basepoint, Q public key\\n     *       Returns affine representation of point (normalized)       \\n     *      */\\n    function ecZZ_mulmuladd(\\n        uint256 Q0,\\n        uint256 Q1, //affine rep for input point Q\\n        uint256 scalar_u,\\n        uint256 scalar_v\\n    ) internal view returns (uint256 X, uint256 Y) {\\n        uint256 zz;\\n        uint256 zzz;\\n        uint256 index = 255;\\n        uint256[6] memory T;\\n        uint256[2] memory H;\\n \\n        unchecked {\\n            if (scalar_u == 0 && scalar_v == 0) return (0,0);\\n\\n            (H[0], H[1]) = ecAff_add(gx, gy, Q0, Q1); //will not work if Q=P, obvious forbidden private key\\n\\n            assembly {\\n                for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\\n                    index := sub(index, 1)\\n                    T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n                } {}\\n                zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                if eq(zz, 1) {\\n                    X := gx\\n                    Y := gy\\n                }\\n                if eq(zz, 2) {\\n                    X := Q0\\n                    Y := Q1\\n                }\\n                if eq(zz, 3) {\\n                    Y := mload(add(H,32))\\n                    X := mload(H)\\n                }\\n\\n                index := sub(index, 1)\\n                zz := 1\\n                zzz := 1\\n\\n                for {} gt(minus_1, index) { index := sub(index, 1) } {\\n                    // inlined EcZZ_Dbl\\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                    let T2 := mulmod(T1, T1, p) // V=U^2\\n                    let T3 := mulmod(X, T2, p) // S = X1*V\\n                    T1 := mulmod(T1, T2, p) // W=UV\\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                    {\\n                        //value of dibit\\n                        T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                        if iszero(T4) {\\n                            Y := sub(p, Y) //restore the -Y inversion\\n                            continue\\n                        } // if T4!=0\\n\\n                        if eq(T4, 1) {\\n                            T1 := gx\\n                            T2 := gy\\n                        }\\n                        if eq(T4, 2) {\\n                            T1 := Q0\\n                            T2 := Q1\\n                        }\\n                        if eq(T4, 3) {\\n                            T1 := mload(H)\\n                            T2 := mload(add(H,32))\\n                        }\\n                        if iszero(zz) {\\n                            X := T1\\n                            Y := T2\\n                            zz := 1\\n                            zzz := 1\\n                            continue\\n                        }\\n                        // inlined EcZZ_AddN\\n\\n                        //T3:=sub(p, Y)\\n                        //T3:=Y\\n                        let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\\n                        T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\\n\\n                        //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\\n                        //todo : construct edge vector case\\n                        if iszero(y2) {\\n                            if iszero(T2) {\\n                                T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\\n                                T2 := mulmod(T1, T1, p) // V=U^2\\n                                T3 := mulmod(X, T2, p) // S = X1*V\\n\\n                                T1 := mulmod(T1, T2, p) // W=UV\\n                                y2 := addmod(X, zz, p) //X+ZZ\\n                                let TT1 := addmod(X, sub(p, zz), p) //X-ZZ\\n                                y2 := mulmod(y2, TT1, p) //(X-ZZ)(X+ZZ)\\n                                T4 := mulmod(3, y2, p) //M\\n\\n                                zzz := mulmod(TT1, zzz, p) //zzz3=W*zzz1\\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\\n\\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\\n\\n                                continue\\n                            }\\n                        }\\n\\n                        T4 := mulmod(T2, T2, p) //PP\\n                        let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\\n                        zz := mulmod(zz, T4, p)\\n                        zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\\n                        let TT2 := mulmod(X, T4, p)\\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\\n                        Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\\n\\n                        X := T4\\n                    }\\n                } //end loop\\n                mstore(add(T, 0x60), zzz)\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                Y:=mulmod(Y,mload(T),p)//Y/zzz\\n                zz :=mulmod(zz, mload(T),p) //1/z\\n                zz:= mulmod(zz,zz,p) //1/zz\\n                X := mulmod(X, zz, p) //X/zz\\n            } //end assembly\\n        } //end unchecked\\n\\n        return (X,Y);\\n    }\\n\\n    //8 dimensions Shamir's trick, using precomputations stored in Shamir8,  stored as Bytecode of an external\\n    //contract at given address dataPointer\\n    //(thx to Lakhdar https://github.com/Kelvyne for EVM storage explanations and tricks)\\n    // the external tool to generate tables from public key is in the /sage directory\\n    function ecZZ_mulmuladd_S8_extcode(uint256 scalar_u, uint256 scalar_v, address dataPointer)\\n        internal view\\n        returns (uint256 X /*, uint Y*/ )\\n    {\\n        unchecked {\\n            uint256 zz; // third and  coordinates of the point\\n\\n            uint256[6] memory T;\\n            zz = 256; //start index\\n\\n            while (T[0] == 0) {\\n                zz = zz - 1;\\n                //tbd case of msb octobit is null\\n                T[0] = 64\\n                    * (\\n                        128 * ((scalar_v >> zz) & 1) + 64 * ((scalar_v >> (zz - 64)) & 1)\\n                            + 32 * ((scalar_v >> (zz - 128)) & 1) + 16 * ((scalar_v >> (zz - 192)) & 1)\\n                            + 8 * ((scalar_u >> zz) & 1) + 4 * ((scalar_u >> (zz - 64)) & 1)\\n                            + 2 * ((scalar_u >> (zz - 128)) & 1) + ((scalar_u >> (zz - 192)) & 1)\\n                    );\\n            }\\n            assembly {\\n                extcodecopy(dataPointer, T, mload(T), 64)\\n                let index := sub(zz, 1)\\n                X := mload(T)\\n                let Y := mload(add(T, 32))\\n                let zzz := 1\\n                zz := 1\\n\\n                //loop over 1/4 of scalars thx to Shamir's trick over 8 points\\n                for {} gt(index, 191) { index := add(index, 191) } {\\n                    //inline Double\\n                    {\\n                        let TT1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                        let T2 := mulmod(TT1, TT1, p) // V=U^2\\n                        let T3 := mulmod(X, T2, p) // S = X1*V\\n                        let T1 := mulmod(TT1, T2, p) // W=UV\\n                        let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                        zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                        zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                        X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                        //T2:=mulmod(T4,addmod(T3, sub(p, X),p),p)//M(S-X3)\\n                        let T5 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n\\n                        //Y:= addmod(T2, sub(p, mulmod(T1, Y ,p)),p  )//Y3= M(S-X3)-W*Y1\\n                        Y := addmod(mulmod(T1, Y, p), T5, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                        /* compute element to access in precomputed table */\\n                    }\\n                    {\\n                        let T4 := add(shl(13, and(shr(index, scalar_v), 1)), shl(9, and(shr(index, scalar_u), 1)))\\n                        let index2 := sub(index, 64)\\n                        let T3 :=\\n                            add(T4, add(shl(12, and(shr(index2, scalar_v), 1)), shl(8, and(shr(index2, scalar_u), 1))))\\n                        let index3 := sub(index2, 64)\\n                        let T2 :=\\n                            add(T3, add(shl(11, and(shr(index3, scalar_v), 1)), shl(7, and(shr(index3, scalar_u), 1))))\\n                        index := sub(index3, 64)\\n                        let T1 :=\\n                            add(T2, add(shl(10, and(shr(index, scalar_v), 1)), shl(6, and(shr(index, scalar_u), 1))))\\n\\n                        //tbd: check validity of formulae with (0,1) to remove conditional jump\\n                        if iszero(T1) {\\n                            Y := sub(p, Y)\\n\\n                            continue\\n                        }\\n                        extcodecopy(dataPointer, T, T1, 64)\\n                    }\\n\\n                    {\\n                        /* Access to precomputed table using extcodecopy hack */\\n\\n                        // inlined EcZZ_AddN\\n                        if iszero(zz) {\\n                            X := mload(T)\\n                            Y := mload(add(T, 32))\\n                            zz := 1\\n                            zzz := 1\\n\\n                            continue\\n                        }\\n\\n                        let y2 := addmod(mulmod(mload(add(T, 32)), zzz, p), Y, p)\\n                        let T2 := addmod(mulmod(mload(T), zz, p), sub(p, X), p)\\n\\n                        //special case ecAdd(P,P)=EcDbl\\n                        if iszero(y2) {\\n                            if iszero(T2) {\\n                                let T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\\n                                T2 := mulmod(T1, T1, p) // V=U^2\\n                                let T3 := mulmod(X, T2, p) // S = X1*V\\n\\n                                T1 := mulmod(T1, T2, p) // W=UV\\n                                y2 := addmod(X, zz, p) //X+ZZ\\n                                let TT1 := addmod(X, sub(p, zz), p) //X-ZZ\\n                                y2 := mulmod(y2, TT1, p) //(X-ZZ)(X+ZZ)\\n                                let T4 := mulmod(3, y2, p) //M\\n\\n                                zzz := mulmod(TT1, zzz, p) //zzz3=W*zzz1\\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\\n\\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\\n\\n                                continue\\n                            }\\n                        }\\n\\n                        let T4 := mulmod(T2, T2, p)\\n                        let T1 := mulmod(T4, T2, p) //\\n                        zz := mulmod(zz, T4, p)\\n                        //zzz3=V*ZZ1\\n                        zzz := mulmod(zzz, T1, p) // W=UV/\\n                        let zz1 := mulmod(X, T4, p)\\n                        X := addmod(addmod(mulmod(y2, y2, p), sub(p, T1), p), mulmod(minus_2, zz1, p), p)\\n                        Y := addmod(mulmod(addmod(zz1, sub(p, X), p), y2, p), mulmod(Y, T1, p), p)\\n                    }\\n                } //end loop\\n                mstore(add(T, 0x60), zz)\\n\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                zz := mload(T)\\n                X := mulmod(X, zz, p) //X/zz\\n            }\\n        } //end unchecked\\n    }\\n\\n   \\n\\n    // improving the extcodecopy trick : append array at end of contract\\n    function ecZZ_mulmuladd_S8_hackmem(uint256 scalar_u, uint256 scalar_v, uint256 dataPointer)\\n        internal view\\n        returns (uint256 X /*, uint Y*/ )\\n    {\\n        uint256 zz; // third and  coordinates of the point\\n\\n        uint256[6] memory T;\\n        zz = 256; //start index\\n\\n        unchecked {\\n            while (T[0] == 0) {\\n                zz = zz - 1;\\n                //tbd case of msb octobit is null\\n                T[0] = 64\\n                    * (\\n                        128 * ((scalar_v >> zz) & 1) + 64 * ((scalar_v >> (zz - 64)) & 1)\\n                            + 32 * ((scalar_v >> (zz - 128)) & 1) + 16 * ((scalar_v >> (zz - 192)) & 1)\\n                            + 8 * ((scalar_u >> zz) & 1) + 4 * ((scalar_u >> (zz - 64)) & 1)\\n                            + 2 * ((scalar_u >> (zz - 128)) & 1) + ((scalar_u >> (zz - 192)) & 1)\\n                    );\\n            }\\n            assembly {\\n                codecopy(T, add(mload(T), dataPointer), 64)\\n                X := mload(T)\\n                let Y := mload(add(T, 32))\\n                let zzz := 1\\n                zz := 1\\n\\n                //loop over 1/4 of scalars thx to Shamir's trick over 8 points\\n                for { let index := 254 } gt(index, 191) { index := add(index, 191) } {\\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                    let T2 := mulmod(T1, T1, p) // V=U^2\\n                    let T3 := mulmod(X, T2, p) // S = X1*V\\n                    T1 := mulmod(T1, T2, p) // W=UV\\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                    //T2:=mulmod(T4,addmod(T3, sub(p, X),p),p)//M(S-X3)\\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n\\n                    //Y:= addmod(T2, sub(p, mulmod(T1, Y ,p)),p  )//Y3= M(S-X3)-W*Y1\\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                    /* compute element to access in precomputed table */\\n                    T4 := add(shl(13, and(shr(index, scalar_v), 1)), shl(9, and(shr(index, scalar_u), 1)))\\n                    index := sub(index, 64)\\n                    T4 := add(T4, add(shl(12, and(shr(index, scalar_v), 1)), shl(8, and(shr(index, scalar_u), 1))))\\n                    index := sub(index, 64)\\n                    T4 := add(T4, add(shl(11, and(shr(index, scalar_v), 1)), shl(7, and(shr(index, scalar_u), 1))))\\n                    index := sub(index, 64)\\n                    T4 := add(T4, add(shl(10, and(shr(index, scalar_v), 1)), shl(6, and(shr(index, scalar_u), 1))))\\n                    //index:=add(index,192), restore index, interleaved with loop\\n\\n                    //tbd: check validity of formulae with (0,1) to remove conditional jump\\n                    if iszero(T4) {\\n                        Y := sub(p, Y)\\n\\n                        continue\\n                    }\\n                    {\\n                        /* Access to precomputed table using extcodecopy hack */\\n                        codecopy(T, add(T4, dataPointer), 64)\\n\\n                        // inlined EcZZ_AddN\\n\\n                        let y2 := addmod(mulmod(mload(add(T, 32)), zzz, p), Y, p)\\n                        T2 := addmod(mulmod(mload(T), zz, p), sub(p, X), p)\\n                        T4 := mulmod(T2, T2, p)\\n                        T1 := mulmod(T4, T2, p)\\n                        T2 := mulmod(zz, T4, p) // W=UV\\n                        zzz := mulmod(zzz, T1, p) //zz3=V*ZZ1\\n                        let zz1 := mulmod(X, T4, p)\\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, T1), p), mulmod(minus_2, zz1, p), p)\\n                        Y := addmod(mulmod(addmod(zz1, sub(p, T4), p), y2, p), mulmod(Y, T1, p), p)\\n                        zz := T2\\n                        X := T4\\n                    }\\n                } //end loop\\n                mstore(add(T, 0x60), zz)\\n\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                zz := mload(T)\\n                X := mulmod(X, zz, p) //X/zz\\n            }\\n        } //end unchecked\\n    }\\n\\n    /**\\n     * @dev ECDSA verification, given , signature, and public key.\\n     */\\n    function ecdsa_verify(bytes32 message, uint256[2] calldata rs, uint256[2] calldata Q) internal view returns (bool) {\\n        uint256 r = rs[0];\\n        uint256 s = rs[1];\\n        if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return false;\\n        }\\n        uint256 Q0 = Q[0];\\n        uint256 Q1 = Q[1];\\n        if (!ecAff_isOnCurve(Q0, Q1)) {\\n            return false;\\n        }\\n\\n        uint256 sInv = FCL_nModInv(s);\\n\\n        uint256 scalar_u = mulmod(uint256(message), sInv, n);\\n        uint256 scalar_v = mulmod(r, sInv, n);\\n        uint256 x1;\\n\\n        x1 = ecZZ_mulmuladd_S_asm(Q0, Q1, scalar_u, scalar_v);\\n\\n        assembly {\\n            x1 := addmod(x1, sub(n, r), n)\\n        }\\n        //return true;\\n        return x1 == 0;\\n    }\\n\\n    /**\\n     * @dev ECDSA verification using a precomputed table of multiples of P and Q stored in contract at address Shamir8\\n     *     generation of contract bytecode for precomputations is done using sagemath code\\n     *     (see sage directory, WebAuthn_precompute.sage)\\n     */\\n\\n    function ecdsa_precomputed_verify(bytes32 message, uint256[2] calldata rs, address Shamir8)\\n        internal view\\n        returns (bool)\\n    {\\n        uint256 r = rs[0];\\n        uint256 s = rs[1];\\n        if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return false;\\n        }\\n        /* Q is pushed via bytecode assumed to be correct\\n        if (!isOnCurve(Q[0], Q[1])) {\\n            return false;\\n        }*/\\n\\n        uint256 sInv = FCL_nModInv(s);\\n\\n        uint256 X;\\n\\n        //Shamir 8 dimensions\\n        X = ecZZ_mulmuladd_S8_extcode(mulmod(uint256(message), sInv, n), mulmod(r, sInv, n), Shamir8);\\n\\n        assembly {\\n            X := addmod(X, sub(n, r), n)\\n        }\\n\\n        return X == 0;\\n    } //end  ecdsa_precomputed_verify()\\n\\n    /**\\n     * @dev ECDSA verification using a precomputed table of multiples of P and Q appended at end of contract at address endcontract\\n     *     generation of contract bytecode for precomputations is done using sagemath code\\n     *     (see sage directory, WebAuthn_precompute.sage)\\n     */\\n\\n    function ecdsa_precomputed_hackmem(bytes32 message, uint256[2] calldata rs, uint256 endcontract)\\n        internal view\\n        returns (bool)\\n    {\\n        uint256 r = rs[0];\\n        uint256 s = rs[1];\\n        if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return false;\\n        }\\n        /* Q is pushed via bytecode assumed to be correct\\n        if (!isOnCurve(Q[0], Q[1])) {\\n            return false;\\n        }*/\\n\\n        uint256 sInv = FCL_nModInv(s);\\n        uint256 X;\\n\\n        //Shamir 8 dimensions\\n        X = ecZZ_mulmuladd_S8_hackmem(mulmod(uint256(message), sInv, n), mulmod(r, sInv, n), endcontract);\\n\\n        assembly {\\n            X := addmod(X, sub(n, r), n)\\n        }\\n        return X == 0;\\n    } //end  ecdsa_precomputed_verify()\\n\\n    function ec_recover_r1(uint256 h, uint256 v, uint256 r, uint256 s) public view returns (address)\\n    {\\n         if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return address(0);\\n        }\\n        uint256 y=ec_Decompress(r, v-27);\\n        uint256 rinv=FCL_nModInv(r);\\n        uint256 u1=mulmod(n-addmod(0,h,n), rinv,n);//-hr^-1\\n        uint256 u2=mulmod(s, rinv,n);//sr^-1\\n\\n        uint256 Qx;\\n        uint256 Qy;\\n        (Qx,Qy)=ecZZ_mulmuladd(r,y, u1, u2);\\n\\n        return address(uint160(uint256(keccak256(abi.encodePacked(Qx, Qy)))));\\n    }\\n\\n    //ecdsa signature for test purpose only (who would like to have a private key onchain anyway ?)\\n    //K is nonce, kpriv is private key\\n    function ecdsa_sign(bytes32 message, uint256 k , uint256 kpriv) public view returns(uint256 r, uint256 s)\\n    {\\n        r=ecZZ_mulmuladd_S_asm(0,0, k, 0) ;//Calculate the curve point k.G (abuse ecmulmul add with v=0)\\n        r=addmod(0,r, n); \\n        s=mulmod(FCL_nModInv(k), addmod(uint256(message), mulmod(r, kpriv, n),n),n);//s=k^-1.(h+r.kpriv)\\n\\n        \\n        if(r==0||s==0){\\n            revert();\\n        }\\n\\n\\n    }\\n\\n} //EOF\\n\",\"keccak256\":\"0xd6c3e555eae02916f6b9d65db6509d7ddf0fd76d5399e29dbc1502e0b7d992a6\",\"license\":\"MIT\"},\"FreshCryptoLib/utils/Base64Url.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Encode (without '=' padding) \\n * @author evmbrahmin, adapted from hiromin's Base64URL libraries\\n */\\nlibrary Base64Url {\\n    /**\\n     * @dev Base64Url Encoding Table\\n     */\\n    string internal constant ENCODING_TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Load the table into memory\\n        string memory table = ENCODING_TABLE;\\n\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        // @solidity memory-safe-assembly\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                mstore8(\\n                    resultPtr,\\n                    mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n\\n                mstore8(\\n                    resultPtr,\\n                    mload(add(tablePtr, and(shr(12, input), 0x3F)))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n\\n                mstore8(\\n                    resultPtr,\\n                    mload(add(tablePtr, and(shr(6, input), 0x3F)))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // Remove the padding adjustment logic\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                // Adjust for the last byte of data\\n                resultPtr := sub(resultPtr, 2)\\n            }\\n            case 2 {\\n                // Adjust for the last two bytes of data\\n                resultPtr := sub(resultPtr, 1)\\n            }\\n            \\n            // Set the correct length of the result string\\n            mstore(result, sub(resultPtr, add(result, 32)))\\n        }\\n\\n        return result;  \\n    }\\n}\\n\",\"keccak256\":\"0xc9d5fbb0ef9ff0756eb5aabe7a32b2bf0f8f3c533d4451dd5778fe77aee7f0c1\",\"license\":\"Apache-2.0\"},\"contracts/FCL/WrapperFCLWebAuthn.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport {FCL_WebAuthn} from \\\"FreshCryptoLib/FCL_Webauthn.sol\\\";\\n\\n/// @title WrapperFCLWebAuthn\\n/// @notice A library used to verify ECDSA signatures over secp256r1 through\\n///         EIP-1271 of Webauthn payloads.\\n/// @dev This lib is only a wrapper around the FCL_WebAuthn library.\\n///      It is meant to be used with 1271 signatures.\\n///      The wrapping is necessary because the FCL_WebAuthn has only internal\\n///      functions and use calldata. This makes it impossible to use it with\\n///      isValidSignature that use memory.\\nlibrary WrapperFCLWebAuthn {\\n    function checkSignature(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        uint256[2] calldata Q\\n    ) external view returns (bool) {\\n        return FCL_WebAuthn.checkSignature(\\n            authenticatorData,\\n            authenticatorDataFlagMask,\\n            clientData,\\n            clientChallenge,\\n            clientChallengeDataOffset,\\n            rs,\\n            Q\\n        );\\n    }\\n}\",\"keccak256\":\"0x21b11feafba10e0db2399a46a1d5d30a93c39d0f1c384f43ac43f4988b5d0586\"}},\"version\":1}",
  "bytecode": "0x611a3c61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c80630d5efec91461003a575b600080fd5b61004d61004836600461179d565b610061565b604051901515815260200160405180910390f35b60006100748a8a8a8a8a8a8a8a8a610082565b9a9950505050505050505050565b6000806100958b8b8b8b8b8b8b8b6100b4565b905060006100a4828686610357565b9c9b505050505050505050505050565b60007fff000000000000000000000000000000000000000000000000000000000000008716878a8a60208181106100ed576100ed61187c565b9050013560f81c60f81b167effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614610151576040517ffc93479200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061017d8560405160200161016991815260200190565b6040516020818303038152906040526104b9565b90506000815167ffffffffffffffff81111561019b5761019b6118ab565b6040519080825280601f01601f1916602001820160405280156101c5576020820181803683370190505b50905080518589016020830137600081516020830120905080836040516020016101ef91906118da565b604051602081830303815290604052805190602001201461023c576040517febab5d2900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b506000915061024e9050896020611938565b67ffffffffffffffff811115610266576102666118ab565b6040519080825280601f01601f191660200182016040528015610290576020820181803683370190505b509050888a60208301376000600288886040516102ae92919061194b565b602060405180830381855afa1580156102cb573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906102ee919061195b565b90508060208b0183015260028260405161030891906118da565b602060405180830381855afa158015610325573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190610348919061195b565b9b9a5050505050505050505050565b60008235602084013581158061038d57507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518210155b80610396575080155b806103c157507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518110155b156103d1576000925050506104b2565b833560208501356103e28282610628565b6103f35760009450505050506104b2565b60006103fe846107a1565b905060007fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551828b09905060007fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518388099050600061045e86868585610825565b90507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551887fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255103820815985050505050505050505b9392505050565b606081516000036104d857505060408051602081019091526000815290565b60006040518060600160405280604081526020016119c760409139905060006003845160026105079190611938565b6105119190611974565b61051c9060046119af565b67ffffffffffffffff811115610534576105346118ab565b6040519080825280601f01601f19166020018201604052801561055e576020820181803683370190505b509050600182016020820185865187015b808210156105ca576003820191508151603f8160121c168501518453600184019350603f81600c1c168501518453600184019350603f8160061c168501518453600184019350603f811685015184535060018301925061056f565b50506003865106600181146105e657600281146105f1576105f8565b6002820391506105f8565b6001820391505b508290037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0018252509392505050565b600082158061065657507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff83145b8061065f575081155b8061068957507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff82145b156106965750600061079b565b60007fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838409905060007fffffffff00000001000000000000000000000000ffffffffffffffffffffffff807fffffffff00000001000000000000000000000000fffffffffffffffffffffffc87097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff877fffffffff00000001000000000000000000000000ffffffffffffffffffffffff898a09090890507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff7f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b8208919091149150505b92915050565b600060405160208152602080820152602060408201528260608201527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254f60808201527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255160a082015260208160c0836005600019fa61081e57600080fd5b5192915050565b600080808060ff81808815801561083a575087155b1561084e57600096505050505050506112e6565b61089a7f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2967f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f58d8d6112ee565b8092508193505050600189841c16600189851c1660011b015b806108d55760018403935060018a851c1660018a861c1660011b0190506108b3565b50600189841c16600189851c1660011b01955060018603610937577f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29696507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f593505b60028603610946578a96508993505b60038603610955578196508093505b60018303925060019550600194505b827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff111561123c577fffffffff00000001000000000000000000000000ffffffffffffffffffffffff846002097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8182097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff818a097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff82840992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff807fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b8d087fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8c7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038e08096003097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff89850998507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a840999507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80837fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838409089a507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80837fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038d08820992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff837fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a870908975060018d881c1660018d891c1660011b01905080610c4057877fffffffff00000001000000000000000000000000ffffffffffffffffffffffff03975050505050611231565b60018103610c8f577f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29693507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f592505b60028103610c9e578e93508d92505b60038103610cad578593508492505b89610cc657509198506001975087965094506112319050565b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff887fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b8609087fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8c7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8d88090893508061102a578361102a577fffffffff00000001000000000000000000000000ffffffffffffffffffffffff897fffffffff00000001000000000000000000000000fffffffffffffffffffffffd0994507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff85860993507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff848d0992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff84860994507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b8d0890507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038d087fffffffff00000001000000000000000000000000ffffffffffffffffffffffff81830991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8260030992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b82099a50507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b85099a507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80847fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff848509089b507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff808d7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038508830993507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff808a8709850898505050505050611231565b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff84850991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8483097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838d099b507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff818c099a507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838e097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80827fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff847fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff878809080893507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80838d097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff857fffffffff00000001000000000000000000000000ffffffffffffffffffffffff887fffffffff00000001000000000000000000000000ffffffffffffffffffffffff03860809089a50505050809a50505050505b600183039250610964565b60405186606082015260208152602080820152602060408201527fffffffff00000001000000000000000000000000fffffffffffffffffffffffd60808201527fffffffff00000001000000000000000000000000ffffffffffffffffffffffff60a082015260208160c0836005600019fa6112b757600080fd5b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff815189099750505050505050505b949350505050565b600080808086611305578585935093505050611343565b84611317578787935093505050611343565b61132688886001808a8a61134c565b929a509098509250905061133c88888484611611565b9350935050505b94509492505050565b6000806000808860000361136b57508492508391506001905080611604565b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff9889039889818988090894507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a89090895507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff86870993507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff86850992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff84890991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff83880990507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff848b0997507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80897fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff857fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff898a09080893507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80848b097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff877fffffffff00000001000000000000000000000000ffffffffffffffffffffffff887fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038d08090892505b9650965096509692505050565b600080600061161f846116c6565b90507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff818709915060007fffffffff00000001000000000000000000000000ffffffffffffffffffffffff82870990507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff81820991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8289099350505094509492505050565b600060405160208152602080820152602060408201528260608201527fffffffff00000001000000000000000000000000fffffffffffffffffffffffd60808201527fffffffff00000001000000000000000000000000ffffffffffffffffffffffff60a082015260208160c0836005600019fa61081e57600080fd5b60008083601f84011261175557600080fd5b50813567ffffffffffffffff81111561176d57600080fd5b60208301915083602082850101111561178557600080fd5b9250929050565b806040810183101561079b57600080fd5b60008060008060008060008060006101208a8c0312156117bc57600080fd5b893567ffffffffffffffff808211156117d457600080fd5b6117e08d838e01611743565b909b50995060208c013591507fff000000000000000000000000000000000000000000000000000000000000008216821461181a57600080fd5b90975060408b0135908082111561183057600080fd5b5061183d8c828d01611743565b90975095505060608a0135935060808a0135925061185e8b60a08c0161178c565b915061186d8b60e08c0161178c565b90509295985092959850929598565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000825160005b818110156118fb57602081860181015185830152016118e1565b506000920191825250919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561079b5761079b611909565b8183823760009101908152919050565b60006020828403121561196d57600080fd5b5051919050565b6000826119aa577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b808202811582820484141761079b5761079b61190956fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5fa2646970667358221220a5a42b5a5048bdf6322d6fa3052df01e1a197bbb61722775e8f972389e441d9964736f6c63430008140033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c80630d5efec91461003a575b600080fd5b61004d61004836600461179d565b610061565b604051901515815260200160405180910390f35b60006100748a8a8a8a8a8a8a8a8a610082565b9a9950505050505050505050565b6000806100958b8b8b8b8b8b8b8b6100b4565b905060006100a4828686610357565b9c9b505050505050505050505050565b60007fff000000000000000000000000000000000000000000000000000000000000008716878a8a60208181106100ed576100ed61187c565b9050013560f81c60f81b167effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614610151576040517ffc93479200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061017d8560405160200161016991815260200190565b6040516020818303038152906040526104b9565b90506000815167ffffffffffffffff81111561019b5761019b6118ab565b6040519080825280601f01601f1916602001820160405280156101c5576020820181803683370190505b50905080518589016020830137600081516020830120905080836040516020016101ef91906118da565b604051602081830303815290604052805190602001201461023c576040517febab5d2900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b506000915061024e9050896020611938565b67ffffffffffffffff811115610266576102666118ab565b6040519080825280601f01601f191660200182016040528015610290576020820181803683370190505b509050888a60208301376000600288886040516102ae92919061194b565b602060405180830381855afa1580156102cb573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906102ee919061195b565b90508060208b0183015260028260405161030891906118da565b602060405180830381855afa158015610325573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190610348919061195b565b9b9a5050505050505050505050565b60008235602084013581158061038d57507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518210155b80610396575080155b806103c157507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518110155b156103d1576000925050506104b2565b833560208501356103e28282610628565b6103f35760009450505050506104b2565b60006103fe846107a1565b905060007fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551828b09905060007fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518388099050600061045e86868585610825565b90507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551887fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255103820815985050505050505050505b9392505050565b606081516000036104d857505060408051602081019091526000815290565b60006040518060600160405280604081526020016119c760409139905060006003845160026105079190611938565b6105119190611974565b61051c9060046119af565b67ffffffffffffffff811115610534576105346118ab565b6040519080825280601f01601f19166020018201604052801561055e576020820181803683370190505b509050600182016020820185865187015b808210156105ca576003820191508151603f8160121c168501518453600184019350603f81600c1c168501518453600184019350603f8160061c168501518453600184019350603f811685015184535060018301925061056f565b50506003865106600181146105e657600281146105f1576105f8565b6002820391506105f8565b6001820391505b508290037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0018252509392505050565b600082158061065657507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff83145b8061065f575081155b8061068957507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff82145b156106965750600061079b565b60007fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838409905060007fffffffff00000001000000000000000000000000ffffffffffffffffffffffff807fffffffff00000001000000000000000000000000fffffffffffffffffffffffc87097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff877fffffffff00000001000000000000000000000000ffffffffffffffffffffffff898a09090890507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff7f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b8208919091149150505b92915050565b600060405160208152602080820152602060408201528260608201527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254f60808201527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255160a082015260208160c0836005600019fa61081e57600080fd5b5192915050565b600080808060ff81808815801561083a575087155b1561084e57600096505050505050506112e6565b61089a7f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2967f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f58d8d6112ee565b8092508193505050600189841c16600189851c1660011b015b806108d55760018403935060018a851c1660018a861c1660011b0190506108b3565b50600189841c16600189851c1660011b01955060018603610937577f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29696507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f593505b60028603610946578a96508993505b60038603610955578196508093505b60018303925060019550600194505b827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff111561123c577fffffffff00000001000000000000000000000000ffffffffffffffffffffffff846002097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8182097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff818a097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff82840992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff807fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b8d087fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8c7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038e08096003097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff89850998507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a840999507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80837fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838409089a507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80837fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038d08820992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff837fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a870908975060018d881c1660018d891c1660011b01905080610c4057877fffffffff00000001000000000000000000000000ffffffffffffffffffffffff03975050505050611231565b60018103610c8f577f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29693507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f592505b60028103610c9e578e93508d92505b60038103610cad578593508492505b89610cc657509198506001975087965094506112319050565b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff887fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b8609087fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8c7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8d88090893508061102a578361102a577fffffffff00000001000000000000000000000000ffffffffffffffffffffffff897fffffffff00000001000000000000000000000000fffffffffffffffffffffffd0994507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff85860993507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff848d0992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff84860994507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b8d0890507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038d087fffffffff00000001000000000000000000000000ffffffffffffffffffffffff81830991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8260030992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b82099a50507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8b85099a507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80847fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff848509089b507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff808d7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038508830993507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff808a8709850898505050505050611231565b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff84850991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8483097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838d099b507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff818c099a507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff838e097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80827fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff847fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff878809080893507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80838d097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff857fffffffff00000001000000000000000000000000ffffffffffffffffffffffff887fffffffff00000001000000000000000000000000ffffffffffffffffffffffff03860809089a50505050809a50505050505b600183039250610964565b60405186606082015260208152602080820152602060408201527fffffffff00000001000000000000000000000000fffffffffffffffffffffffd60808201527fffffffff00000001000000000000000000000000ffffffffffffffffffffffff60a082015260208160c0836005600019fa6112b757600080fd5b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff815189099750505050505050505b949350505050565b600080808086611305578585935093505050611343565b84611317578787935093505050611343565b61132688886001808a8a61134c565b929a509098509250905061133c88888484611611565b9350935050505b94509492505050565b6000806000808860000361136b57508492508391506001905080611604565b7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff9889039889818988090894507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a7fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8a89090895507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff86870993507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff86850992507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff84890991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff83880990507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff848b0997507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80897fffffffff00000001000000000000000000000000fffffffffffffffffffffffd097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff857fffffffff00000001000000000000000000000000ffffffffffffffffffffffff037fffffffff00000001000000000000000000000000ffffffffffffffffffffffff898a09080893507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff80848b097fffffffff00000001000000000000000000000000ffffffffffffffffffffffff877fffffffff00000001000000000000000000000000ffffffffffffffffffffffff887fffffffff00000001000000000000000000000000ffffffffffffffffffffffff038d08090892505b9650965096509692505050565b600080600061161f846116c6565b90507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff818709915060007fffffffff00000001000000000000000000000000ffffffffffffffffffffffff82870990507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff81820991507fffffffff00000001000000000000000000000000ffffffffffffffffffffffff8289099350505094509492505050565b600060405160208152602080820152602060408201528260608201527fffffffff00000001000000000000000000000000fffffffffffffffffffffffd60808201527fffffffff00000001000000000000000000000000ffffffffffffffffffffffff60a082015260208160c0836005600019fa61081e57600080fd5b60008083601f84011261175557600080fd5b50813567ffffffffffffffff81111561176d57600080fd5b60208301915083602082850101111561178557600080fd5b9250929050565b806040810183101561079b57600080fd5b60008060008060008060008060006101208a8c0312156117bc57600080fd5b893567ffffffffffffffff808211156117d457600080fd5b6117e08d838e01611743565b909b50995060208c013591507fff000000000000000000000000000000000000000000000000000000000000008216821461181a57600080fd5b90975060408b0135908082111561183057600080fd5b5061183d8c828d01611743565b90975095505060608a0135935060808a0135925061185e8b60a08c0161178c565b915061186d8b60e08c0161178c565b90509295985092959850929598565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000825160005b818110156118fb57602081860181015185830152016118e1565b506000920191825250919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561079b5761079b611909565b8183823760009101908152919050565b60006020828403121561196d57600080fd5b5051919050565b6000826119aa577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b808202811582820484141761079b5761079b61190956fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5fa2646970667358221220a5a42b5a5048bdf6322d6fa3052df01e1a197bbb61722775e8f972389e441d9964736f6c63430008140033",
  "devdoc": {
    "details": "This lib is only a wrapper around the FCL_WebAuthn library.      It is meant to be used with 1271 signatures.      The wrapping is necessary because the FCL_WebAuthn has only internal      functions and use calldata. This makes it impossible to use it with      isValidSignature that use memory.",
    "kind": "dev",
    "methods": {},
    "title": "WrapperFCLWebAuthn",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "A library used to verify ECDSA signatures over secp256r1 through         EIP-1271 of Webauthn payloads.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}